Here's a complete modular Terraform setup for provisioning and accessing AWS AuroraDB, integrating with GitHub Actions, and storing credentials securely in AWS Secrets Manager.


---

✅ Architecture Overview

Aurora MySQL DB cluster in private subnets

Secrets Manager stores DB credentials

IAM roles allow Lambda/EC2 (or CI) to access secrets

Terraform modules structure with remote state

GitHub Actions CI/CD automates provisioning



---

📁 Folder Structure (Terraform Modules)

terraform/
├── main.tf
├── backend.tf
├── variables.tf
├── outputs.tf
├── modules/
│   ├── vpc/
│   ├── aurora/
│   ├── secrets_manager/
│   └── iam/


---

🧩 Module: vpc

modules/vpc/main.tf

resource "aws_vpc" "this" {
  cidr_block = var.vpc_cidr
  ...
}

resource "aws_subnet" "private" {
  count             = length(var.private_subnet_cidrs)
  vpc_id            = aws_vpc.this.id
  cidr_block        = var.private_subnet_cidrs[count.index]
  map_public_ip_on_launch = false
  ...
}

modules/vpc/variables.tf

variable "vpc_cidr" {}
variable "private_subnet_cidrs" {
  type = list(string)
}

modules/vpc/outputs.tf

output "private_subnet_ids" {
  value = aws_subnet.private[*].id
}
output "vpc_id" {
  value = aws_vpc.this.id
}


---

🧩 Module: aurora

modules/aurora/main.tf

resource "aws_rds_cluster" "aurora" {
  cluster_identifier      = var.cluster_identifier
  engine                  = "aurora-mysql"
  master_username         = var.db_username
  master_password         = var.db_password
  vpc_security_group_ids  = [var.db_sg_id]
  db_subnet_group_name    = aws_db_subnet_group.this.name
  ...
}

resource "aws_rds_cluster_instance" "instances" {
  count              = var.instance_count
  identifier         = "${var.cluster_identifier}-${count.index}"
  cluster_identifier = aws_rds_cluster.aurora.id
  instance_class     = var.instance_class
  engine             = "aurora-mysql"
}

modules/aurora/variables.tf

variable "cluster_identifier" {}
variable "db_username" {}
variable "db_password" {}
variable "instance_count" { default = 2 }
variable "instance_class" { default = "db.t3.medium" }
variable "db_sg_id" {}
variable "subnet_ids" {
  type = list(string)
}

modules/aurora/outputs.tf

output "endpoint" {
  value = aws_rds_cluster.aurora.endpoint
}
output "reader_endpoint" {
  value = aws_rds_cluster.aurora.reader_endpoint
}


---

🧩 Module: secrets_manager

modules/secrets_manager/main.tf

resource "aws_secretsmanager_secret" "aurora_secret" {
  name = var.secret_name
}

resource "aws_secretsmanager_secret_version" "version" {
  secret_id     = aws_secretsmanager_secret.aurora_secret.id
  secret_string = jsonencode({
    username = var.db_username
    password = var.db_password
  })
}

modules/secrets_manager/variables.tf

variable "secret_name" {}
variable "db_username" {}
variable "db_password" {}

modules/secrets_manager/outputs.tf

output "secret_arn" {
  value = aws_secretsmanager_secret.aurora_secret.arn
}


---

🧩 Module: iam

modules/iam/main.tf

resource "aws_iam_policy" "secrets_access" {
  name   = "SecretsManagerAccessPolicy"
  policy = jsonencode({
    Version = "2012-10-17",
    Statement = [{
      Effect   = "Allow",
      Action   = ["secretsmanager:GetSecretValue"],
      Resource = var.secret_arn
    }]
  })
}

resource "aws_iam_role" "app_role" {
  name = "AppSecretsAccessRole"
  ...
  assume_role_policy = data.aws_iam_policy_document.assume.json
}

resource "aws_iam_role_policy_attachment" "attach" {
  role       = aws_iam_role.app_role.name
  policy_arn = aws_iam_policy.secrets_access.arn
}


---

🔧 terraform/main.tf

module "vpc" {
  source               = "./modules/vpc"
  vpc_cidr             = "10.0.0.0/16"
  private_subnet_cidrs = ["10.0.1.0/24", "10.0.2.0/24"]
}

module "secrets" {
  source       = "./modules/secrets_manager"
  secret_name  = "aurora-db-credentials"
  db_username  = var.db_username
  db_password  = var.db_password
}

module "aurora" {
  source           = "./modules/aurora"
  cluster_identifier = "aurora-cluster"
  db_username      = var.db_username
  db_password      = var.db_password
  instance_count   = 2
  db_sg_id         = module.security_group.db_sg_id
  subnet_ids       = module.vpc.private_subnet_ids
}


---

📤 outputs.tf

output "aurora_endpoint" {
  value = module.aurora.endpoint
}
output "aurora_reader_endpoint" {
  value = module.aurora.reader_endpoint
}
output "secret_arn" {
  value = module.secrets.secret_arn
}


---

🔐 GitHub Actions CI/CD Example (.github/workflows/terraform.yml)

name: Terraform Apply

on:
  push:
    branches: [main]

jobs:
  terraform:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v3

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Terraform Init
        run: terraform init

      - name: Terraform Plan
        run: terraform plan

      - name: Terraform Apply
        run: terraform apply -auto-approve


---

✅ Best Practices

Area	Practice

Modules	Use one module per responsibility (VPC, DB, Secrets, IAM)
Secrets	Never hardcode credentials—use secretsmanager
IAM	Follow the principle of least privilege
Security	Keep Aurora in private subnets
CI/CD	Use GitHub secrets and workflows to manage credentials securely
Outputs	Only export non-sensitive outputs
Terraform State	Use remote backend (e.g., S3 + DynamoDB)



---

Would you like me to generate this code as files in a downloadable bundle or show it in the canvas editor for iteration?


