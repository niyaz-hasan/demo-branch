Here's a complete modular Terraform setup for provisioning and accessing AWS AuroraDB, integrating with GitHub Actions, and storing credentials securely in AWS Secrets Manager.


---

âœ… Architecture Overview

Aurora MySQL DB cluster in private subnets

Secrets Manager stores DB credentials

IAM roles allow Lambda/EC2 (or CI) to access secrets

Terraform modules structure with remote state

GitHub Actions CI/CD automates provisioning



---

ğŸ“ Folder Structure (Terraform Modules)

terraform/
â”œâ”€â”€ main.tf
â”œâ”€â”€ backend.tf
â”œâ”€â”€ variables.tf
â”œâ”€â”€ outputs.tf
â”œâ”€â”€ modules/
â”‚   â”œâ”€â”€ vpc/
â”‚   â”œâ”€â”€ aurora/
â”‚   â”œâ”€â”€ secrets_manager/
â”‚   â””â”€â”€ iam/


---

ğŸ§© Module: vpc

modules/vpc/main.tf

resource "aws_vpc" "this" {
  cidr_block = var.vpc_cidr
  ...
}

resource "aws_subnet" "private" {
  count             = length(var.private_subnet_cidrs)
  vpc_id            = aws_vpc.this.id
  cidr_block        = var.private_subnet_cidrs[count.index]
  map_public_ip_on_launch = false
  ...
}

modules/vpc/variables.tf

variable "vpc_cidr" {}
variable "private_subnet_cidrs" {
  type = list(string)
}

modules/vpc/outputs.tf

output "private_subnet_ids" {
  value = aws_subnet.private[*].id
}
output "vpc_id" {
  value = aws_vpc.this.id
}


---

ğŸ§© Module: aurora

modules/aurora/main.tf

resource "aws_rds_cluster" "aurora" {
  cluster_identifier      = var.cluster_identifier
  engine                  = "aurora-mysql"
  master_username         = var.db_username
  master_password         = var.db_password
  vpc_security_group_ids  = [var.db_sg_id]
  db_subnet_group_name    = aws_db_subnet_group.this.name
  ...
}

resource "aws_rds_cluster_instance" "instances" {
  count              = var.instance_count
  identifier         = "${var.cluster_identifier}-${count.index}"
  cluster_identifier = aws_rds_cluster.aurora.id
  instance_class     = var.instance_class
  engine             = "aurora-mysql"
}

modules/aurora/variables.tf

variable "cluster_identifier" {}
variable "db_username" {}
variable "db_password" {}
variable "instance_count" { default = 2 }
variable "instance_class" { default = "db.t3.medium" }
variable "db_sg_id" {}
variable "subnet_ids" {
  type = list(string)
}

modules/aurora/outputs.tf

output "endpoint" {
  value = aws_rds_cluster.aurora.endpoint
}
output "reader_endpoint" {
  value = aws_rds_cluster.aurora.reader_endpoint
}


---

ğŸ§© Module: secrets_manager

modules/secrets_manager/main.tf

resource "aws_secretsmanager_secret" "aurora_secret" {
  name = var.secret_name
}

resource "aws_secretsmanager_secret_version" "version" {
  secret_id     = aws_secretsmanager_secret.aurora_secret.id
  secret_string = jsonencode({
    username = var.db_username
    password = var.db_password
  })
}

modules/secrets_manager/variables.tf

variable "secret_name" {}
variable "db_username" {}
variable "db_password" {}

modules/secrets_manager/outputs.tf

output "secret_arn" {
  value = aws_secretsmanager_secret.aurora_secret.arn
}


---

ğŸ§© Module: iam

modules/iam/main.tf

resource "aws_iam_policy" "secrets_access" {
  name   = "SecretsManagerAccessPolicy"
  policy = jsonencode({
    Version = "2012-10-17",
    Statement = [{
      Effect   = "Allow",
      Action   = ["secretsmanager:GetSecretValue"],
      Resource = var.secret_arn
    }]
  })
}

resource "aws_iam_role" "app_role" {
  name = "AppSecretsAccessRole"
  ...
  assume_role_policy = data.aws_iam_policy_document.assume.json
}

resource "aws_iam_role_policy_attachment" "attach" {
  role       = aws_iam_role.app_role.name
  policy_arn = aws_iam_policy.secrets_access.arn
}


---

ğŸ”§ terraform/main.tf

module "vpc" {
  source               = "./modules/vpc"
  vpc_cidr             = "10.0.0.0/16"
  private_subnet_cidrs = ["10.0.1.0/24", "10.0.2.0/24"]
}

module "secrets" {
  source       = "./modules/secrets_manager"
  secret_name  = "aurora-db-credentials"
  db_username  = var.db_username
  db_password  = var.db_password
}

module "aurora" {
  source           = "./modules/aurora"
  cluster_identifier = "aurora-cluster"
  db_username      = var.db_username
  db_password      = var.db_password
  instance_count   = 2
  db_sg_id         = module.security_group.db_sg_id
  subnet_ids       = module.vpc.private_subnet_ids
}


---

ğŸ“¤ outputs.tf

output "aurora_endpoint" {
  value = module.aurora.endpoint
}
output "aurora_reader_endpoint" {
  value = module.aurora.reader_endpoint
}
output "secret_arn" {
  value = module.secrets.secret_arn
}


---

ğŸ” GitHub Actions CI/CD Example (.github/workflows/terraform.yml)

name: Terraform Apply

on:
  push:
    branches: [main]

jobs:
  terraform:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v3

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Terraform Init
        run: terraform init

      - name: Terraform Plan
        run: terraform plan

      - name: Terraform Apply
        run: terraform apply -auto-approve


---

âœ… Best Practices

Area	Practice

Modules	Use one module per responsibility (VPC, DB, Secrets, IAM)
Secrets	Never hardcode credentialsâ€”use secretsmanager
IAM	Follow the principle of least privilege
Security	Keep Aurora in private subnets
CI/CD	Use GitHub secrets and workflows to manage credentials securely
Outputs	Only export non-sensitive outputs
Terraform State	Use remote backend (e.g., S3 + DynamoDB)



---

Would you like me to generate this code as files in a downloadable bundle or show it in the canvas editor for iteration?


